/*
 * Timer based Blink
 *
 * This is another way to get a more precise time delay, using a
 * timer. 
 *
 * The STM32 chips have a number of timers associated with them from
 * simple to quite complex. ST tries to keep timers with the same name
 * on every chip to have the same characteristics. As a result you
 * can have a timer called "TIM6" (logically timer 6) which is on a
 * part with only 4 timers. 
 *
 * In this case TIM6, aka Timer 6, is a really simple implementation of
 * the timer and doesn't have the fancy capture and PWM features that
 * the more sophisticated timers have. That makes it idea for using as
 * a simple delay timer.
 *
 * BSD 2-Clause License
 * 
 * Copyright (C) 2013-2020 Chuck McManis <cmcmanis@mcmanis.com>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdint.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/timer.h>
#include "../common.h"

int
main(void)
{
	/*
	 * Set the clock rate to 168 MHz (see ../common/clock.c)
	 * This also sets the precalers for APB1 (the "slow" peripheral
	 * bus) and APB2 (the "fast" peripheral bus). In this case:
	 *     APB1 Clock Rate - 42 MHz
	 *     APB2 Clock Rate - 84 MHz
	 *
	 * Also, we don't bother enabling SysTick since we're using the
	 * timer for our time delay.
	 */
	nucleo_clock_setup(0);
	/* Set up our on board LED */
	led_setup();

	/* Enable our timer */
	rcc_periph_clock_enable(RCC_TIM6);

	/*
	 * The timer clocks are generated by the peripheral bus they are attached
	 * to by default. If the prescaler is set to anything other than 1 (in the
	 * clock code I set them to 4 for APB1, and 2 for APB1), the timer clock
	 * is 2x the APB clock. Timer 6 is attached to APB1 so its clocked
	 * internally at 2 * 42 MHz or 84 MHz. Note you can connect them directly
	 * to PCLK (the system clock) using the RCC_DCLKCFGR register TMPRE bit.
	 *
	 * The timer clock goes into a prescaler (TIM6_PSC) which is a 'divide
	 * by n' where n is (PSC value + 1) (so if the PSC has 0 in it, which
	 * is the default, it divides by (0 + 1) or 1. Using the prescaler,
	 * we can set the interval between counts. The PSC is a 16 bit unsigned
	 * value so the maximum prescale value is 65,536 (65,535 + 1).
	 *
	 * For example, setting PSC to 83, equivalent to divide by 84, the
	 * timer will divide the 84 MHz clock to a 1 MHz clock. Thus each count
	 * in the timer represents 1 uS in time. Alternatively, setting it to 8399
	 * means the clock is 10 kHz so each count represents 100 uS.
	 *
	 * Timer 6's count is loaded into the ARR register. For timer 6, it only
	 * counts up (other counters have more flexible counting schemes).
	 *
	 * It is important to note that the UIF flag is set on *overflow*. What
	 * that means for this code is that the counter goes up to the count loaded
	 * into ARR, and then ONE MORE COUNT before it overflows. So one way to
	 * think of that is that the ARR register is one less than the actual
	 * delay. 
	 *
	 * Timer 6's prescaler and count are both 16 bit values, the timer counts
	 * up, so setting the count (ARR) to 0xffff means it will count all the
	 * way to 65,535 and then one more count to overflow. Thus the maximum
	 * delay you could create in this situation is 65536 / 1281.7383 or 51.1
	 * seconds.
	 *
	 * Some chips have Timer 5 and Timer 2 which are 32 bit counters and
	 * can give you much longer delays.
	 */
	TIM6_PSC = 8399; 		/* Each 'tick' is 100 uS */
	while (1) {
		TIM6_ARR = 499; 	/* (499 + 1) * .100 mS = 50 mS */
		led_toggle();		/* Alternates every loop: blinks rate 10 Hz */
		/* clear status register */
		TIM6_SR = 0;
		/* start timer in 'one shot' (OPM) counting up to 1000. */
		TIM6_CR1 = TIM_CR1_OPM | TIM_CR1_CEN;
		/* We're done when the event flag goes true */
		while (!(TIM6_SR & TIM_SR_UIF));
	}
}
